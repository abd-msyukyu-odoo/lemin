proteger tous les refill lemin ? pas forcement utile mais on perd des addresses


modifier ft_read pour pouvoir parametrer la recherche de lecture


algo_lecture

lire jusque \n
l1 : uniquement nombre (autre = ERROR)
	-> f(espace, nombre, espace)

1 -> lire jusque # || - || \0
-> si #
	-> lire les rooms f(espace, (!L#)non-espace, espace, nombre, espace, nombre, espace)
		-> si doublon room || ligne vide || erronnee || \0
			-> ERROR
	-> au # nouvelle lecture jusque \n || \0
	-> si commence par #
		-> si commande connue 
			-> si commande valide (pas 2x start ou 2x end)
				-> nouvelle lecture jusque \n
				-> lire 1 room
				-> si room valide
					-> COMMANDE
					-> REDO 1
				-> sinon
					-> ERROR
			-> sinon
				-> ERROR
		-> sinon si \n
			-> REDO 1
		-> si \0
			-> ERROR
	-> sinon si \n
		-> REDO 1
	-> si \0
		-> ERROR
-> si -
	-> si !start || !end
		-> ERROR
	-> lire les rooms avec recherche du - en firewall
		-> si doublon room || ligne vide
			-> ERROR
	-> lire jusque \n || \0 (la suite du -) f(espace, (!L#)non-espace, espace, -, espace, (!L#)non-espace, espace)
		-> lire 1 tube
		-> si doublon tube || ligne vide || erronnee
			-> ERROR
		-> si \0
			-> STOP
	2 -> lire jusque # || \0
	-> lire les tubes f(espace, (!L#)non-espace, espace, -, espace, (!L#)non-espace, espace)
		-> si doublon tube || ligne vide || erronnee || \0
			-> STOP (BFS devra dire si ERROR ou pas)
	-> si #
		-> lire jusque \n
		-> REDO 2
-> sinon
	-> STOP







-> retirer les bzero des hmap dans la libft
-> iterer le tableau et set root a NULL
-> pour les remove -> set root a NULL



->ft_mbtree_initialize > 1





transition 9 vers 10 dans test_mhmap -> hash_btree a ete modifie

destroyed mbnode = right de root

call :
ft_mhmap_add
ft_mbtree_add
ft_mbtree_construct_leaves

a faire :
=> faire un test de thashmap separe de mhmap pour voir si la meme erreur se produit
	-> si erreur : erreur dans btree OU hmap OU typemanager
	-> si pas erreur : erreur dans memanager

possibilites :
ft_memanager_get_as_is_addr => spot on dude ;)



ce qui est sur : une addresse de noeud est donnee alors qu'elle est utilisee.
ce noeud est de type : t_bnode et fourni par le memanager

=> hypothese : l'addresse du noeud est disponible dans le memanager alors qu'elle ne devrait pas
-> hypothese verifiee.
=> hypothese : l'addresse est presente sous 2 tailles differentes apres le refill
-> hypothese verifiee
=> on lui rend 2 fois a des moments differents
=> probleme dans le code de la hmap ou dans tbtree/mbtree OU mauvaise recombinaison de 2 addresses
-> situation : a la base c'est un noeud d'un btree dans une hmap

-> verification : afficher le memanager a chaque addition, puis chaque suppression puis chaque addition


a regarder : 0xc00430

premier usage : 78
premiere suppression 2123
deuxieme suppression 2491


cible : quand on supprime un element, le noeud possedant l'element ne change pas forcement.
	=> switch de l'element a retirer avec un autre noeud
cible : quand on supprime un element dont un des enfant est une feuille, une feuille et lui meme disparaissent


a tester : mbtree ajouter retirer ajouter + afficher le memanager








visu lemin : adaptation de la camera

capturer la position de la camera